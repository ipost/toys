<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
        body {
            font-family: "Helvetica Neue", "Arial", sans-serif;
            line-height: 1.6;
        }
        #polySettings > div:nth-child(2n) {
            background-color: #CCCCCC;
        }
        .enableColumn > input {
            width: 100%;
        }
        .colorColumn > input {
            width: 100%;
        }
        .degreeColumn > input {
            width: 100%;
        }
        .xIntervalColumn > input {
            width: 100%;
        }
    </style>
</head>
<body>
<canvas id="myCanvas" width="800" height="600" style="border:2px solid black;margin:auto"></canvas>
<input type="button" value="Clear" id="clearBtn">

<div>
    <label>Axiom: <input type="text" id="axiom" value="0"></label>
    <label>Iterations: <input type="number" id="iterations" value="4"></label>
    <label>Segment Length: <input type="number" id="segmentLength" value="5"></label>
    <label>Turn angle: <input type="number" id="turnAngle" value="60"></label>
    <div>
        Rules<br>
        <div class="rule"><input type="text" value="1" class="pred">→<input type="text" value="11" class="succ"></div>
        <div class="rule"><input type="text" value="0" class="pred">→<input type="text" value="1[0]0" class="succ"></div>
        <div class="rule"><input type="text" value="A" class="pred">→<input type="text" value="+B-A-B+" class="succ"></div>
        <div class="rule"><input type="text" value="B" class="pred">→<input type="text" value="-A+B+A-" class="succ"></div>
    </div>
    <div id="eq"></div>
</div>
<script type="text/javascript">
    function clearCanvas() {
        var context = getContext();
        context.canvas.width = context.canvas.width;
    }
    var instructions = {
        '0': drawForward,
        '1': drawForward,
        'A': drawForward,
        'B': drawForward,
        'F': drawForward,
        'X': function(){},
        '[': function (pos, stack) {
            pushPos(pos, stack);
            turnLeft(pos, turnAngle);
        },
        ']': function (pos, stack) {
            popPos(pos, stack);
            turnLeft(pos, -1 * turnAngle);
        },
        '-': function (pos) {
            turnLeft(pos, turnAngle);
        },
        '+': function (pos) {
            turnLeft(pos, -1 * turnAngle);
        },
    };
    var segmentLength = 5;
    var turnAngle = 60;
    function render() {
        clearCanvas();
        var iterations = parseInt(document.getElementById('iterations').value);
        segmentLength = parseInt(document.getElementById('segmentLength').value);
        turnAngle = parseInt(document.getElementById('turnAngle').value);
        var rules = {};
        [].slice.call(document.querySelectorAll('.rule')).forEach(function(ruleDiv) {
            rules[ruleDiv.querySelector('.pred').value] = ruleDiv.querySelector('.succ').value;
        });
        var state = document.getElementById('axiom').value;
        for (var i = 0; i < iterations; i++) {
            state = applyRules(state, rules);
        }
        document.querySelector('#eq').innerHTML = state;
        var pos = {x: document.getElementById('myCanvas').width / 2, y: document.getElementById('myCanvas').height, facing: -90};
        var stack = [];
        state.split('').forEach(function (instr) {
            instructions[instr](pos, stack);
        });
    }
    function drawForward(pos) {
        var endPos = {
            x: pos.x + (segmentLength * Math.cos(pos.facing * Math.PI / 180)),
            y: pos.y + (segmentLength * Math.sin(pos.facing * Math.PI / 180))
        };
        drawLine(pos, endPos, '#000');
        pos.x = endPos.x;
        pos.y = endPos.y;
    }
    function clone(o) {
        return JSON.parse(JSON.stringify(o));
    }
    function pushPos(pos, stack) {
        stack.push(clone(pos));
    }
    function popPos(pos, stack) {
        var p = stack.pop();
        pos.x = p.x;
        pos.y = p.y;
        pos.facing = p.facing;
    }
    function turnLeft(p, degrees) {
        p.facing = p.facing + degrees;
    }
    function applyRules(state, rules) {
        return state.split('').map(function (ch) {
            return rules[ch] ? rules[ch] : ch;
        }).join('');
    }
    function drawLine(startPoint, endPoint, color) {
        var c = getContext();
        c.beginPath();
        c.moveTo(startPoint.x, startPoint.y);
        c.lineTo(endPoint.x, endPoint.y);
        var previousColor = c.strokeStyle;
        c.lineWidth = 3;
        c.strokeStyle = color;
        c.stroke();
        c.strokeStyle = previousColor;
    }
    function getContext() {
        return document.getElementById("myCanvas").getContext("2d");
    }
    function drawPoint(coords) {
        var c = getContext();
        var radius = 2;
        c.beginPath();
        c.lineWidth = 2;
        c.arc(coords.x - (radius / 2), coords.y - (radius / 2), 3, 0, 2 * Math.PI);
        c.stroke();
    }
    [].slice.call(document.querySelectorAll("input")).forEach(function (i) {
        i.onchange = function () {
            render();
        }
    });
    render();
</script>
</body>
</html>
